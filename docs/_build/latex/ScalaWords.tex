% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[a4paper,10pt,oneside,openany]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\PassOptionsToPackage{warn}{textcomp} \usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}
\definecolor{VerbatimColor}{rgb}{0.935,0.935,0.935}

\title{ ScalaWords Documentation}
\date{August 04, 2012}
\release{0.1}
\author{Project13 - Konrad Malawski}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.47,0.47,0.40}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.47,0.47,0.40}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.47,0.47,0.40}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.47,0.47,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.47,0.47,0.40}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.94,0.94,0.94}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}



\chapter{Introduction}
\label{intro/index:scalawords-docs}\label{intro/index:introduction}\label{intro/index::doc}

\section{What is Scala Words?}
\label{intro/what-is-scala-words:what-is-scala-words}\label{intro/what-is-scala-words::doc}\label{intro/what-is-scala-words:id1}
\textbf{Pleasant utilities, for common tasks}

We believe that writing correct concurrent, fault-tolerant and scalable
applications is too hard. Most of the time it's because we are using the wrong
tools and the wrong level of abstraction. Akka is here to change that. Using the
Actor Model we raise the abstraction level and provide a better platform to build
correct concurrent and scalable applications. For fault-tolerance we adopt the
``Let it crash'' model which have been used with great success in the telecom industry to build
applications that self-heals, systems that never stop. Actors also provides the
abstraction for transparent distribution and the basis for truly scalable and
fault-tolerant applications.

ScalaWords is Open Source and available under the Apache 2 License.


\subsection{Akka implements a unique hybrid}
\label{intro/what-is-scala-words:akka-implements-a-unique-hybrid}

\subsubsection{Actors}
\label{intro/what-is-scala-words:actors}
Actors give you:
\begin{itemize}
\item {} 
Simple and high-level abstractions for concurrency and parallelism.

\item {} 
Asynchronous, non-blocking and highly performant event-driven programming model.

\item {} 
Very lightweight event-driven processes (approximately 2.7 million actors per GB RAM).

\end{itemize}

See \emph{actors-scala} and \emph{untyped-actors-java}


\subsubsection{Fault Tolerance}
\label{intro/what-is-scala-words:fault-tolerance}
Fault tolerance through supervisor hierarchies with ``let-it-crash''
semantics. Excellent for writing highly fault-tolerant systems that never stop,
systems that self-heal. Supervisor hierarchies can span over multiple JVMs to
provide truly fault-tolerant systems.

See \emph{fault-tolerance-scala} and \emph{fault-tolerance-java}


\subsubsection{Location Transparency}
\label{intro/what-is-scala-words:location-transparency}
Everything in Akka is designed to work in a distributed environment: all
interactions of actors use purely message passing and everything is asynchronous.

For an overview of the remoting see \emph{remoting}


\subsubsection{Transactors}
\label{intro/what-is-scala-words:transactors}
Transactors combine actors and STM (Software Transactional Memory) into transactional actors.
It allows you to compose atomic message flows with automatic retry and rollback.

See \emph{transactors-scala} and \emph{transactors-java}


\subsection{Scala and Java APIs}
\label{intro/what-is-scala-words:scala-and-java-apis}
Akka has both a \emph{scala-api} and a \emph{java-api}.


\subsection{Akka can be used in two different ways}
\label{intro/what-is-scala-words:akka-can-be-used-in-two-different-ways}\begin{itemize}
\item {} 
As a library: used by a web app, to be put into \code{WEB-INF/lib} or as a regular
JAR on your classpath.

\item {} 
As a microkernel: stand-alone kernel to drop your application into.

\end{itemize}

See the \emph{deployment-scenarios} for details.


\subsection{What happened to Cloudy Akka?}
\label{intro/what-is-scala-words:what-happened-to-cloudy-akka}
The commercial offering was earlier referred to as Cloudy Akka. This offering
consisted of two things:
\begin{itemize}
\item {} 
Cluster support for Akka

\item {} 
Monitoring \& Management (formerly called Atmos)

\end{itemize}

Cloudy Akka have been discontinued and the Cluster support is now being moved into the
Open Source version of Akka (the upcoming Akka 2.1), while the Monitoring \& Management
(Atmos) is now rebranded into Typesafe Console and is part of the commercial subscription
for the Typesafe Stack (see below for details).


\subsection{Typesafe Stack}
\label{intro/what-is-scala-words:typesafe-stack}
Akka is now also part of the \href{http://typesafe.com/stack}{Typesafe Stack}.

The Typesafe Stack is a modern software platform that makes it easy for developers
to build scalable software applications. It combines the Scala programming language,
Akka, the Play! web framework and robust developer tools in a simple package that
integrates seamlessly with existing Java infrastructure.

The Typesafe Stack is all fully open source.


\subsection{Typesafe Console}
\label{intro/what-is-scala-words:typesafe-console}
On top of the Typesafe Stack we have also have commercial product called Typesafe
Console which provides the following features:
\begin{enumerate}
\item {} 
Slick Web UI with real-time view into the system

\item {} 
Management through Dashboard, JMX and REST

\item {} 
Dapper-style tracing of messages across components and remote nodes

\item {} 
Real-time statistics

\item {} 
Very low overhead monitoring agents (should always be on in production)

\item {} 
Consolidation of statistics and logging information to a single node

\item {} 
Storage of statistics data for later processing

\item {} 
Provisioning and rolling upgrades

\end{enumerate}

Read more \href{http://typesafe.com/products/typesafe-subscription}{here}.


\section{Getting Started}
\label{intro/getting-started:getting-started}\label{intro/getting-started::doc}

\subsection{Dependencies}
\label{intro/getting-started:dependencies}
ScalaWords is designed with the thought that you'll include all dependencies you'll need.

For example: don't need \code{MongoStream}? Don't include mogo in your dependencies - you'll never bump into using a Mongo Verb by accident anyway ;-)

What we do require though is Google Guava.

So to include ScalaWords in your build use this snippet:

\begin{Verbatim}[commandchars=\\\{\}]
// TODO
val guava =
val scalaWords =

val rainbow = "pl.project13.scala" \% "rainbow" \% "0.1"

dependencies ++= Seq(scalaWords, guava)
\end{Verbatim}


\section{How to use Words?}
\label{intro/getting-started:how-to-use-words}
Each Word (with one or two documented exceptions) can be used in one of the following ways:


\subsection{Via Mixin}
\label{intro/getting-started:via-mixin}
The simplest way to use ScalaWords is to mixin the word you need.
This also has the advantage of clearly letting everyone know you'll be using some word in this file.


\subsection{Via Import}
\label{intro/getting-started:via-import}
You can simply import all methods from a word using such construct:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{import} \PYG{n+nn}{TimedVerb.\PYGZus{}}
\end{Verbatim}

Please note that putting this in the imports section of your file may be handy, but it may confuse people with the
typical ``\emph{Where did that implicit come from?!}''. Instead, try to import just near the place where you'll be using the Word like in the example bellow:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{Something}\PYG{o}{(}\PYG{n}{magicIsReal}\PYG{k}{:} \PYG{k+kt}{Boolean}\PYG{o}{)} \PYG{o}{\PYGZob{}}

  \PYG{k}{def} \PYG{n}{doMagic}\PYG{o}{(}\PYG{o}{)} \PYG{k}{=} \PYG{o}{\PYGZob{}}
    \PYG{k}{import} \PYG{n+nn}{UnlessWord.\PYGZus{}}
    \PYG{l+s}{"Magic is "} \PYG{o}{+} \PYG{l+s}{"NOT "}\PYG{o}{.}\PYG{n}{unless}\PYG{o}{(}\PYG{n}{magicIsReal}\PYG{o}{)} \PYG{o}{+} \PYG{l+s}{"real!"}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}


\subsection{Recommended when you use a lot: Vocabulary pattern}
\label{intro/getting-started:recommended-when-you-use-a-lot-vocabulary-pattern}
If you find yourself using the same words over and over again, it may be time to introduce a \emph{Vocabulary}.

It's nothing else than a trait / object pair (like many Words) that will contain some words,
for easier access - so you won't have to import all words manually each time you need them.

In practive it would look like this:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{trait} \PYG{n+nc}{Vocabulary} \PYG{k}{extends} \PYG{n+nc}{WhenWord}
  \PYG{k}{with} \PYG{n+nc}{UnlessWord}
  \PYG{k}{with} \PYG{n+nc}{DoToVerb}
  \PYG{k}{with} \PYG{n+nc}{TimedVerb}

\PYG{k}{object} \PYG{n+nc}{Vocabulary} \PYG{k}{extends} \PYG{n+nc}{Vocabulary}

\PYG{k}{class} \PYG{n+nc}{MyRepository} \PYG{k}{extends} \PYG{n+nc}{Logging} \PYG{k}{with} \PYG{n+nc}{Vocabulary}
\end{Verbatim}

You can create sets of verbs, and mixin your own when needed. It's a nice idea that plays well with the contept
of ``words''.


\chapter{Verbs}
\label{verbs/index:verbs}\label{verbs/index::doc}

\section{Do To}
\label{verbs/do-to:do-to}\label{verbs/do-to::doc}

\subsection{Use Case}
\label{verbs/do-to:use-case}
You want to apply some operation to an object and then return it.
Sadly, the operation returns Unit (like a setter for example).

You'll typically find such cases when working with  not functional code,
a common example would be non-fluent Plain Old Java Objects from external libraries.


\subsection{Simple application}
\label{verbs/do-to:simple-application}
Although the reducing of used linenumbers here depends on how you format your code,
sometimes you may find using the \code{doTo} verb more readable. We don't suggest over using it though.

With the \code{doTo} verb:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n}{makeAwesomeThing} \PYG{k}{=}
  \PYG{n}{doTo}\PYG{o}{(}\PYG{k}{new} \PYG{n+nc}{Thing}\PYG{o}{)} \PYG{o}{\PYGZob{}} \PYG{k}{\PYGZus{}}\PYG{o}{.}\PYG{n}{setAwesome}\PYG{o}{(}\PYG{k+kc}{true}\PYG{o}{)} \PYG{o}{\PYGZcb{}}
\end{Verbatim}

Without the verb it would be 3 lines:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n}{makeAwesomeThing} \PYG{k}{=} \PYG{o}{\PYGZob{}}
  \PYG{k}{val} \PYG{n}{t} \PYG{k}{=} \PYG{k}{new} \PYG{n+nc}{Thing}
  \PYG{n}{t}\PYG{o}{.}\PYG{n}{setAwesome}\PYG{o}{(}\PYG{k+kc}{true}\PYG{o}{)}
  \PYG{n}{t}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}


\subsection{Multiple application}
\label{verbs/do-to:multiple-application}
Using this \code{doTo} style allows you to use POJOs which dont expose fluent APIs in a ``almost like fluet'' manner:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{val} \PYG{n}{modifiedPojo} \PYG{k}{=} \PYG{n}{doTo}\PYG{o}{(}\PYG{k}{new} \PYG{n+nc}{LongPojo}\PYG{o}{)} \PYG{o}{(}
  \PYG{k}{\PYGZus{}}\PYG{o}{.}\PYG{n}{trim}\PYG{o}{(}\PYG{o}{)}\PYG{o}{,}
  \PYG{k}{\PYGZus{}}\PYG{o}{.}\PYG{n}{setAvailable}\PYG{o}{(}\PYG{k+kc}{false}\PYG{o}{)}\PYG{o}{,}
  \PYG{k}{\PYGZus{}}\PYG{o}{.}\PYG{n}{setUsable}\PYG{o}{(}\PYG{k+kc}{true}\PYG{o}{)}
\PYG{o}{)}
\end{Verbatim}

\begin{notice}{note}{Note:}
You have to use () braces instead of curly braces \{\} in order to use \code{DoToVerb} in this fashion.
\end{notice}


\section{Retry}
\label{verbs/repeat:retry}\label{verbs/repeat::doc}

\subsection{Use Case}
\label{verbs/repeat:use-case}
You want to retry a certain operation which may fail. An example would be making a request to some webservice, which like to timeout once a while and a retry will successfully processa after such failure.

You want to perform some operation multiple times.


\subsection{Retry some operation}
\label{verbs/repeat:retry-some-operation}
The most basic use is to try something up to 3 times:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{object} \PYG{n+nc}{Example} \PYG{k}{extends} \PYG{n+nc}{App} \PYG{k}{with} \PYG{n+nc}{RetryVerb} \PYG{o}{\PYGZob{}}
  \PYG{k}{val} \PYG{n}{res}\PYG{k}{:} \PYG{k+kt}{Either}\PYG{o}{[}\PYG{k+kt}{Seq}\PYG{o}{[}\PYG{k+kt}{Throwable}\PYG{o}{]}, \PYG{k+kt}{Source}\PYG{o}{]} \PYG{k}{=} \PYG{n}{retry}\PYG{o}{(}\PYG{n}{times} \PYG{k}{=} \PYG{l+m+mi}{3}\PYG{o}{)} \PYG{o}{\PYGZob{}}
    \PYG{n}{io}\PYG{o}{.}\PYG{n+nc}{Source}\PYG{o}{.}\PYG{n}{fromURI}\PYG{o}{(}\PYG{l+s}{"http://www.example.com"}\PYG{o}{)}
  \PYG{o}{\PYGZcb{}}

 \PYG{n}{res} \PYG{k}{match} \PYG{o}{\PYGZob{}}
   \PYG{k}{case} \PYG{n+nc}{Left}\PYG{o}{(}\PYG{n}{errors}\PYG{o}{)} \PYG{k}{=\PYGZgt{}} \PYG{n}{errors} \PYG{n}{foreach} \PYG{o}{\PYGZob{}} \PYG{n}{err} \PYG{k}{=\PYGZgt{}} \PYG{n}{sys}\PYG{o}{.}\PYG{n}{error}\PYG{o}{(}\PYG{l+s}{"failed with: "} \PYG{o}{+} \PYG{n}{err}\PYG{o}{)} \PYG{o}{\PYGZcb{}}
   \PYG{k}{case} \PYG{n+nc}{Right}\PYG{o}{(}\PYG{n}{source}\PYG{o}{)} \PYG{k}{=\PYGZgt{}} \PYG{n}{println}\PYG{o}{(}\PYG{l+s}{"We got the source!"}\PYG{o}{)}
 \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

Note that if the block of code will complete without errors the first time around, retry will not call it again.
Another thing to note is, that if the block failed only the first time, the \code{Either} will not contain errors - it's an Either - so it either failed (3 times) or you got your expected result.

\begin{notice}{note}{Note:}
In idiomatic Scala code, \code{Left} is considered as the ``errors'' side of an \code{Either} and \code{Right} is the expected value. Scala Words follows this convention wherever an Either is used. For more details, check out this link: \href{http://www.scala-lang.org/api/current/index.html\#scala.Either}{http://www.scala-lang.org/api/current/index.html\#scala.Either}
\end{notice}


\subsection{Simple tip, how to treat Either as Option}
\label{verbs/repeat:simple-tip-how-to-treat-either-as-option}
If you don't care about the exceptions being thrown, you can simply map over the \emph{right value}.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{val} \PYG{n}{exceptionsOrString} \PYG{k}{=} \PYG{n}{retry}\PYG{o}{(}\PYG{n}{times} \PYG{k}{=} \PYG{l+m+mi}{2}\PYG{o}{)} \PYG{o}{\PYGZob{}} \PYG{l+s}{"Hello"} \PYG{o}{\PYGZcb{}}
\PYG{n}{exceptionsOrString}\PYG{o}{.}\PYG{n}{right} \PYG{n}{map} \PYG{o}{\PYGZob{}} \PYG{n}{println} \PYG{o}{(}\PYG{l+s}{"Got : "} \PYG{o}{+} \PYG{k}{\PYGZus{}}\PYG{o}{)} \PYG{o}{\PYGZcb{}}
\end{Verbatim}


\subsection{Reacting to failures}
\label{verbs/repeat:reacting-to-failures}
Since you may be interested in the faulilures, \code{Retry} has a callback you can define to get this info:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// with UnlessWord}

\PYG{k}{val} \PYG{n}{onException} \PYG{k}{=} \PYG{o}{(}\PYG{n}{n}\PYG{k}{:} \PYG{k+kt}{Int}\PYG{o}{,} \PYG{n}{willRetry}\PYG{k}{:} \PYG{k+kt}{Boolean}\PYG{o}{,} \PYG{n}{ex}\PYG{k}{:} \PYG{k+kt}{Throwable}\PYG{o}{)} \PYG{k}{=\PYGZgt{}} \PYG{o}{\PYGZob{}}
  \PYG{n}{println}\PYG{o}{(}\PYG{l+s}{"Oh no! Failed \PYGZpc{}sth time, and will \PYGZpc{}sretry: \PYGZpc{}s"}
    \PYG{o}{.}\PYG{n}{format}\PYG{o}{(}\PYG{n}{n}\PYG{o}{,} \PYG{l+s}{"NOT "}\PYG{o}{.}\PYG{n}{unless}\PYG{o}{(}\PYG{n}{willRetry}\PYG{o}{)}\PYG{o}{,} \PYG{n}{ex}\PYG{o}{.}\PYG{n}{getMessage}\PYG{o}{)}\PYG{o}{)}
\PYG{o}{\PYGZcb{}}

\PYG{n}{retry}\PYG{o}{(}
  \PYG{n}{times} \PYG{k}{=} \PYG{l+m+mi}{3}\PYG{o}{,}
  \PYG{n}{onException} \PYG{k}{=} \PYG{n}{onException}
\PYG{o}{)} \PYG{o}{\PYGZob{}} \PYG{n}{doThings}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZcb{}}
\end{Verbatim}

Which, as expected, will call \code{onException}  whenever doThings throws an exception.


\subsection{Other hooks: beforeEach and onSuccess}
\label{verbs/repeat:other-hooks-beforeeach-and-onsuccess}
These methods give you information about the state of processing the \code{Retry}.
You may for example use the \code{beforeEach} hook to log information like ``retrying for the nth time...'',
or do something else with the number of retries given to this function.

Similarily, onSuccess would be used to log the number of retries that were used to obtain the value.
It will not be called when all calls caused an exception - then onException will be notified for each of them, and the retult will be an \code{Left{[}Seq{[}Exception{]}{]}}.


\section{Timed}
\label{verbs/timed:timed}\label{verbs/timed::doc}

\subsection{Use Case}
\label{verbs/timed:use-case}
You want to check how long some portion of your code takes to complete.

You can either keep this information as a number, or automatically log it if it's too high.

\begin{notice}{note}{Note:}
\textbf{Duration} is available in both Akka and Scala 2.10, but sadly not before, so for now ScalaWords uses a copied version of the Scala 2.10 implementaiton. It will be removed once more projects are using Scala 2.10.
\end{notice}


\subsection{timed}
\label{verbs/timed:id1}
The simplest version of \code{timed} returns a tuple, with both the time (a \code{Stopwatch} instance) the code took to execute, and the computed value. Exceptions are not eaten, they'll be thrown up as you'd expect.
\DUspan{k}{}\DUspan{o}{}\DUspan{n}{}\DUspan{o}{}\DUspan{n}{}\DUspan{o}{}\DUspan{k}{}\DUspan{n}{}\DUspan{o}{}\DUspan{nc}{}\DUspan{o}{}\DUspan{n}{}\DUspan{o}{}\DUspan{mi}{}\DUspan{o}{}\DUspan{mi}{}\DUspan{o}{}\DUspan{mi}{}\DUspan{o}{}\DUspan{n}{}\DUspan{o}{}\DUspan{s}{}\DUspan{o}{}\DUspan{n}{}\DUspan{o}{}\DUspan{n}{}\DUspan{n}{}\DUspan{o}{}\DUspan{mi}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{val} \PYG{o}{(}\PYG{n}{time}\PYG{o}{,} \PYG{n}{value}\PYG{o}{)} \PYG{k}{=} \PYG{n}{timed} \PYG{o}{\PYGZob{}}
  \PYG{n+nc}{Thread}\PYG{o}{.}\PYG{n}{sleep}\PYG{o}{(}\PYG{l+m+mi}{100}\PYG{o}{)}
  \PYG{l+m+mi}{2} \PYG{o}{+} \PYG{l+m+mi}{2}
\PYG{o}{\PYGZcb{}}

\PYG{n}{println}\PYG{o}{(}\PYG{l+s}{"Exection took: "} \PYG{o}{+} \PYG{n}{time}\PYG{o}{)}
\PYG{n}{assert} \PYG{n}{value} \PYG{o}{==} \PYG{l+m+mi}{4}
\end{Verbatim}


\subsection{timedAndLogged}
\label{verbs/timed:timedandlogged}
One of many examples you might want to use this \emph{Verb} is to log an information message if some block of code is taking too long to complete. You could do this on a method level using AOP, but just using this verb is way easier, and code weaving is something you have to think twice before using anyway ;-)
\DUspan{k}{}\DUspan{nn}{}\DUspan{k}{}\DUspan{nc}{}\DUspan{k}{}\DUspan{nc}{}\DUspan{k}{}\DUspan{nc}{}\DUspan{o}{}\DUspan{k}{}\DUspan{n}{}\DUspan{k}{}\DUspan{n}{}\DUspan{o}{}\DUspan{n}{}\DUspan{o}{}\DUspan{s}{}\DUspan{o}{}\DUspan{o}{}\DUspan{c1}{}\DUspan{nc}{}\DUspan{o}{}\DUspan{n}{}\DUspan{o}{}\DUspan{mi}{}\DUspan{o}{}\DUspan{mi}{}\DUspan{o}{}\DUspan{mi}{}\DUspan{c1}{}\DUspan{o}{}\DUspan{n}{}\DUspan{mi}{}\DUspan{o}{}\DUspan{n}{}\DUspan{o}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{import} \PYG{n+nn}{com.weiglewilczek.sfl4s.Logger}

\PYG{k}{object} \PYG{n+nc}{Test} \PYG{k}{extends} \PYG{n+nc}{Logger} \PYG{k}{with} \PYG{n+nc}{TimedVerb} \PYG{o}{\PYGZob{}}

  \PYG{k}{val} \PYG{n}{hardMathProblemSolution} \PYG{k}{=} \PYG{n}{timedAndLogger}\PYG{o}{(}\PYG{n}{logger}\PYG{o}{,} \PYG{l+s}{"Hard math problem"}\PYG{o}{)} \PYG{o}{\PYGZob{}}
    \PYG{c+c1}{// DEBUG: Starting execution of timed block: [Hard math problem]}
    \PYG{n+nc}{Thread}\PYG{o}{.}\PYG{n}{sleep}\PYG{o}{(}\PYG{l+m+mi}{100}\PYG{o}{)}
    \PYG{l+m+mi}{2} \PYG{o}{+} \PYG{l+m+mi}{2}
    \PYG{c+c1}{// INFO: Timed [Hard math problem] took: 100ms}
  \PYG{o}{\PYGZcb{}}

  \PYG{n}{assert} \PYG{l+m+mi}{4} \PYG{o}{==} \PYG{n}{hardMathProblemSolution}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}

\begin{notice}{note}{Note:}
ScalaWords currently supports the \textbf{com.weiglewilczek.slf4s.Logger}, I'm thinking about a way to allow any logger to work with this API (without the use of \emph{slow} Structural Types).
\end{notice}


\subsection{Log when certain conditions are met}
\label{verbs/timed:log-when-certain-conditions-are-met}
Sometimes you have a LOT of log messages like the above, which you don't really care about.
Let's say most requests are handled within 5ms, but sometimes you get a spike and they take 100ms to process,
that's something worth logging as \emph{WARN}.
\DUspan{n}{}\DUspan{o}{}\DUspan{k}{}\DUspan{o}{}\DUspan{n}{}\DUspan{o}{}\DUspan{mi}{}\DUspan{o}{}\DUspan{n}{}\DUspan{o}{}\DUspan{s}{}\DUspan{o}{}\DUspan{o}{}\DUspan{n}{}\DUspan{o}{}\DUspan{o}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{timedAndLoggedIf}\PYG{o}{(}\PYG{k}{\PYGZus{}}\PYG{o}{.}\PYG{n}{elapsedMillis} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{100}\PYG{o}{)}\PYG{o}{(}\PYG{n}{logger}\PYG{o}{,} \PYG{l+s}{"Long Operation"}\PYG{o}{)} \PYG{o}{\PYGZob{}} \PYG{n}{doThings}\PYG{o}{(}\PYG{o}{)} \PYG{o}{\PYGZcb{}}
\end{Verbatim}


\subsection{Testing with TimedVerb}
\label{verbs/timed:testing-with-timedverb}
As with anything that's Time related, you're probably already thinking ``how would I test such code?''.
\code{Timed} is smart enough to allow you to mock out the ticker it's using, like this:
\DUspan{k}{}\DUspan{nn}{}\DUspan{k}{}\DUspan{nc}{}\DUspan{k}{}\DUspan{nc}{}\DUspan{o}{}\DUspan{k}{}\DUspan{k}{}\DUspan{k}{}\DUspan{n}{}\DUspan{k}{}\DUspan{k}{}\DUspan{nc}{}\DUspan{o}{}\DUspan{k}{}\DUspan{n}{}\DUspan{o}{}\DUspan{k}{}\DUspan{mi}{}\DUspan{o}{}\DUspan{o}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{import} \PYG{n+nn}{com.google.common.base.Ticker}

\PYG{k}{trait} \PYG{n+nc}{TestTimedVerb} \PYG{k}{extends} \PYG{n+nc}{TimedVerb} \PYG{o}{\PYGZob{}}
  \PYG{k}{override} \PYG{k}{lazy} \PYG{k}{val} \PYG{n}{ticker} \PYG{k}{=} \PYG{k}{new} \PYG{n+nc}{Ticker} \PYG{o}{\PYGZob{}}
    \PYG{k}{def} \PYG{n}{read}\PYG{o}{(}\PYG{o}{)} \PYG{k}{=} \PYG{l+m+mi}{0L}
  \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}


\subsection{Override the messages}
\label{verbs/timed:override-the-messages}
You can override the messages being created by this trait.

Setting loglevels manualy is not yet supported, but I'll work on a way to use any logger - and then via callbacks you'll be able to log on any level and any message.


\section{Ask}
\label{verbs/ask:ask}\label{verbs/ask::doc}

\subsection{Use Case}
\label{verbs/ask:use-case}
In simple command line applications you often find yourself writing \emph{println(``Do you want to continue?'')} then read a boolean or String, and match on it... So far so good, but this code tends to duplicate around the codebase, that's what \code{AskVerb} is for.

Ask's goal is to: Simplify typesafe command line interaction with the user.


\subsection{Ask the user}
\label{verbs/ask:ask-the-user}
For each of those methods, if the input the user gives is not valid, he'll be asked again.
When nothing is typed in by the user, the default is used - if there is no default, he'll be asked again.

Also note that the default value will be added ather your question automatically so when you ask:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{ask}\PYG{o}{(}\PYG{l+s}{"Hello?"}\PYG{o}{,} \PYG{k+kc}{false}\PYG{o}{)} \PYG{c+c1}{// prints "Hello? [y/N]"}
\end{Verbatim}

Other examples of ask are listed bellow, but it's always a good idea to take a look at the sourcecode if in doubt.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{object} \PYG{n+nc}{Test} \PYG{k}{extends} \PYG{n+nc}{App} \PYG{k}{with} \PYG{n+nc}{AskVerb} \PYG{o}{\PYGZob{}}
  \PYG{n}{ask}\PYG{o}{(}\PYG{l+s}{"Are you OK?"}\PYG{o}{)} \PYG{c+c1}{// asks until "y" or "n" are given}

  \PYG{n}{ask}\PYG{o}{(}\PYG{l+s}{"Yes or No?"}\PYG{o}{,} \PYG{n+nc}{No}\PYG{o}{)} \PYG{c+c1}{// Yes or No? [y/N]}
  \PYG{n}{ask}\PYG{o}{(}\PYG{l+s}{"Yes or No?"}\PYG{o}{,} \PYG{n+nc}{Yes}\PYG{o}{)} \PYG{c+c1}{// Yes or No? [Y/n]}

  \PYG{n}{ask}\PYG{o}{(}\PYG{l+s}{"Number?"}\PYG{o}{,} \PYG{l+m+mi}{12}\PYG{o}{)} \PYG{c+c1}{// Number? [12]}

  \PYG{n}{ask}\PYG{o}{(}\PYG{l+s}{"Long?"}\PYG{o}{,} \PYG{l+m+mi}{12L}\PYG{o}{)}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}


\subsection{Limiting choice}
\label{verbs/ask:limiting-choice}
You can limit the choices the user can make on a range of numbers, set of strings or better - based an Enumeration.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{object} \PYG{n+nc}{Test} \PYG{k}{extends} \PYG{n+nc}{App} \PYG{k}{with} \PYG{n+nc}{AskVerb} \PYG{o}{\PYGZob{}}

  \PYG{k}{val} \PYG{n}{theNumber} \PYG{k}{=} \PYG{n}{askForIntIn}\PYG{o}{(}\PYG{l+m+mi}{1} \PYG{n}{to} \PYG{l+m+mi}{10}\PYG{o}{,} \PYG{l+s}{"Enter a number?"}\PYG{o}{)}
  \PYG{c+c1}{// prints "Enter a number? (x ∈ [1; 10])"}

  \PYG{n}{assert}\PYG{o}{(}\PYG{n}{theNumber} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{o}{)}
  \PYG{n}{assert}\PYG{o}{(}\PYG{n}{theNumber} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{11}\PYG{o}{)}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}


\subsection{Limiting choice by using  Enumerations}
\label{verbs/ask:limiting-choice-by-using-enumerations}
Instead of \code{Sets} and \code{Ranges} which are quite fine moste of the time, you can also use Enumerations,
to stay a bit more verbose about what you're actually selecting.

Note that the returned type is the selected Enumeration value - we're typesafe about it.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{object} \PYG{n+nc}{Test} \PYG{k}{extends} \PYG{n+nc}{App} \PYG{k}{with} \PYG{n+nc}{AskVerb} \PYG{o}{\PYGZob{}}

  \PYG{k}{object} \PYG{n+nc}{Mode} \PYG{k}{extends} \PYG{n+nc}{Enumeration} \PYG{o}{\PYGZob{}}
    \PYG{k}{type} \PYG{k+kt}{Mode} \PYG{o}{=} \PYG{n+nc}{Value}
    \PYG{k}{val} \PYG{n+nc}{Single}\PYG{o}{,} \PYG{n+nc}{Double} \PYG{k}{=} \PYG{n+nc}{Value}
  \PYG{o}{\PYGZcb{}}

  \PYG{k}{val} \PYG{n}{selected}\PYG{k}{:} \PYG{k+kt}{Mode}\PYG{k+kt}{.}\PYG{k+kt}{Value} \PYG{o}{=} \PYG{n}{askForEnum}\PYG{o}{(}\PYG{n+nc}{Mode}\PYG{o}{,} \PYG{l+s}{"Which mode?"}\PYG{o}{)}
  \PYG{c+c1}{// prints "Which mode? (x ∈ [0:Single, 1:Double])"}
  \PYG{c+c1}{// the user may select by 1, 2 or "Single", "Double"}

  \PYG{n}{selected} \PYG{k}{match} \PYG{o}{\PYGZob{}}
    \PYG{k}{case} \PYG{n+nc}{Mode}\PYG{o}{.}\PYG{n+nc}{Single} \PYG{k}{=\PYGZgt{}} \PYG{c+c1}{// ...}
    \PYG{k}{case} \PYG{n+nc}{Mode}\PYG{o}{.}\PYG{n+nc}{Double} \PYG{k}{=\PYGZgt{}} \PYG{c+c1}{// ...}
  \PYG{o}{\PYGZcb{}}

\PYG{o}{\PYGZcb{}}
\end{Verbatim}


\chapter{Links}
\label{index:links}\begin{itemize}
\item {} 
\href{https://github.com/ktoso/scala-words}{Source Code}

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}
